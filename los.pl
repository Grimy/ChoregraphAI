#!/usr/bin/perl

use strict;
use List::MoreUtils qw(uniq);
$" = ' || '; #"
$\ = $/;

sub id($$) { my ($x, $y) = @_; $y * ($y + 1) / 2 + $x - 1 - ($x == 10)}

sub los($$) {
	my ($x, $y) = @_;
	my $cx = int($x + .5);
	my $cy = int($y + .5);
	my $path = 0;
	return ~0 if $cx > $cy;
	while ($cy) {
		my $err_x = abs(($cx - 1 - $x) * $y - ($cy - $y) * $x);
		my $err_y = abs(($cx - $x) * $y - ($cy - 1 - $y) * $x);
		$path |= 1 << id($cx, $cy) if ($cx < 10 && $cy <= 10);
		$path |= 1 << id($cx - 1, $cy) if ($cx > 0 && abs($err_x - $err_y) < .001);
		--(!$cx || $err_y < $err_x + .001 ? $cy : $cx);
	}
	return $path;
}

print <<'END';
// los.c - code generated by los.pl - DO NOT EDIT!
#include "chore.h"
void cast_light(Tile *tile, i64 x, i64 y) {
Tile *row = tile;
u64 walls = 0;
u64 torch = g.inventory[MEMERS_CAP] ? 5 : 2;
END

for my $y (1..10) {
	print "tile = (row += y);";
	for my $x (0..$y) {
		my @masks = uniq map {$_ & (1 << id($x, $y)) - 1} (
			los($x - .51, $y - .51),
			los($x + .51, $y + .51),
			los($x - .51, $y + .51),
			los($x + .51, $y - .51),
			los($x, $y),
		);
		for my $mask (@masks) {
			@masks = grep {$_ == $mask || $mask &~ $_} @masks;
		}
		@masks = map {sprintf "!(walls & $_)"} grep {~$_} @masks;

		my $l2 = $x * $x + $y * $y;
		print 'if (tile->hp == 5) ', $x == 0 || $y == 10 ? 'return;' :
			sprintf "{ walls |= %#x; goto label$y; }",
				(1 << id($y + 1, $y)) - (1 << id($x, $y));
		print "if (torch >= $l2 || @masks) " if $l2 > 2;
		print 'tile->revealed = true;';
		print('}'), exit if $x == 10;
		printf "walls |= (u64) (tile->class == WALL) << %d;\n", id($x, $y);
		print "tile += x;";
	}
	print "label$y:";
	printf "if (torch < %d && walls >= %#x) return;\n", ($y + 1) * ($y + 1),
		(1 << id($y + 1, $y)) - (1 << id(0, $y));
	printf "if (!(walls & %#x))\ntile->revealed = true;\n", los($y + 1 - .51, $y + .51);
}
